# 计网

## 五层结构

把与互联网相关联的协议集合起来总称为TCP/IP。TCP/IP协议族里重要的一点就是 分层。TCP/IP协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层

![image-20231229155502635](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/202312291555671.png)

把TCP/IP层次化是有好处的。比如，**如果互联网只由一个协议统筹，某个地方需 要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉 即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动 了。**

### 应用层

**应用层(application-layer)的任务是通过应用进程间的交互来完成特定网络应用。应 用层协议定义的是应用进程（(进程：主机中正在运行的程序)间的通信和交互的规 则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如 域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。**我们把应用层**交互的数据单元称为报文**。

### 运输层

**运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通 用的数据传输服务。**应用进程利用该服务传送应用层报文。“通用的”是指并不针对某 一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可 同时运行多个线程，因此运输层有多路复用和多路分解的功能。所谓多路复用就是 指多个应用层套接字可同时使用下面运输层的服务，多路分解是运输层把收到的信 息分别交付上面应用层中的相应套接字。

 **运输层主要使用以下两种协议：**

 **1．传输控制协议TCP(Transmission Control Protocol)--提供面向连接的，可靠的数 据传输服务。**

 **2．用户数据协议UDP (User Datagram Protocol)--提供无连接的，尽最大努力的数 据传输服务(不保证数据传输的可靠性)。**

**通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。**

### 网络层

在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。**网络层的任务就是选择合适的网间路由和交换结点，确 保数据及时传送。**在发送数据时，网络层把运输层产生的报文段或用户数据报封装 成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，**简称数据报**。

### 链路层

两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专 门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来 的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要 的控制信息(如同步信息，地址信息，差错控制等)。在接收数据时，控制信息使接收 端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一 个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到 所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的 帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层 传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错)，那么就要采 用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。

### 物理层

在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计 算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流"表示 经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

### 数据封装过程

首先作为发送端的客户端在应用层(HTTP协议)发出一个想看某个Web页面的 HTTP请求。接着，为了传输方便，在传输层(TCP协议）把从应用层处收到的数据 (HTTP请求报文)进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。

在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样 一来，发往网络的通信请求就准备齐全了。

接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传 输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。

![image-20231229160511089](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/202312291605123.png)

![image-20231229160536067](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/202312291605114.png)

## HTTP

**HTTP是基于TCP/IP协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信协议，默认使用80端口。**

### http常见的状态码类型其作用

#### 1xx

1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。

#### 2xx

2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。

**「200 OK」**是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器 返回的响应头都会有 body 数据。

**「204 No Content」**也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

**「206 Partial Content」**是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

#### 3xx

3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

**「301 Moved Permanently」**表示永久重定向，说明请求的资源已经不存在了， 需改用新的 URL 再次访问。

**「302 Moved Permanently」**表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

**「304 Not Modified」**不具有跳转的含义，表示资源未修改，重定向已存在的缓冲 文件，也称缓存重定向，用于缓存控制。

#### 4xx

4xx 类状态码表示**客户端**发送的**报文有误**，服务器无法处理，也就是错误码的含 义。

**「400 Bad Request」**表示客户端请求的报文有错误，但只是个笼统的错误。

**「403 Forbidden」**表示服务器禁止访问资源，并不是客户端的请求出错。

**「404 Not Found」**表示请求的资源在服务器上不存在或未找到，所以无法提供给 客户端。

#### 5xx

5xx 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于 服务器端的错误码。

**「500 Internal Server Error」**与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

**「501 Not Implemented」**表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。

**「502 Bad Gateway」**通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

**「503 Service Unavailable」**表示服务器当前很忙，暂时无法响应服务器，类似 “网络服务正忙，请稍后重试”的意思。

### URI 和 URL的区别

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资 源。URI 包含 URL 和 URN。
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路 径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

![image-20231229161540936](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/202312291615959.png)

### HTTP的长连接和短连接

#### 短连接

**浏览器和服务器每进行一次HTTP操作就建立一次连接，结束就释放连接。**

例：

从服务器向客户机传送一个Web页面的步骤。假设该页面含有一个基本HTML文件和 10个JPEG图形，并且这11个对象位于同一台服务器上。该HTML文件的URL为: http://www.someSchool.edu/someDepartment/home.index。

1.  HTTP客户机进程在端口号80发起一个到服务器www.someSchool.edu的TCP连接，该端口号是HTTP的默认端口。客户机和服务器上分别有一个套接字与该连接相 关联。
2. HTTP客户机经它的套接字向服务器发送一个HTTP请求报文。请求报文中包含了 路名/someDepartment/home.index。
3. HTTP服务器进程经它的套接字接收该请求报文，从其存储器（RAM或磁盘）中检 索出对象someDepartment/home.index，在一个HTTP响应报文中封装对象，并通 过其套接字向客户机发送响应报文。
4.  HTTP服务器进程通知TCP断开该TCP连接。(但是直到TCP确认客户机已经完整地 收到响应报文为止，它才会真正中断连接。)
5.  HTTP客户机接收响应报文，TCP连接关闭。报文指出封装的对象是一个HTML文 件，客户机从响应报文中提取出该文件，检查该文件，得到对10个JPEG图形的引用。
6. 对每个引用的JPEG图形对象重复前4步。

每个TCP连接在服务器返回对象后关闭，即该连接并不为其他的对象而持续下来。**每个TCP连接只传输一个请求报文和一个响应报文**。这样使得短连接有一些缺点。首 先，必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接， 在客户机和服务器都要分配TCP的缓冲区和变量，这给服务器带来了严重的负担。其 次，每一个对象的传输时延为两个RTT，即一个RTT用于建立TCP，另一个RTT用于 请求和接收一个对象（RTT=往返+排队+数据处理）。

#### 长连接

**服务器在发送响应后保持该TCP连接打开，当浏览器与服务器再次通信会继续使用这个连接**，一般来说，如果一个连接经过一个可配置的超时间隔仍未被使用，HTTP服 务器就关闭该连接。HTTP1.1版本开始的默认模式使用了流水线方式的长连接，长 短连接可通过报文头的connection字段进行设置。

### HTTP报文

#### HTTP请求报文

**HTTP请求报文由3部分组成（请求行+请求头+请求体）：**

![image-20231229162117062](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/202312291621101.png)

#### 请求方法

1.  GET：向服务器请求资源。
2. POST：向指定的资源，提交数据进行处理请求，有可能创建或修改已有数据。
3. PUT：向指定资源位置上传最新的内容。
4. DELETE：请求服务器删除Request-URI所标识的资源。
5.  OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向 web服务器发送‘*’的请求来测试服务器的功能性。
6. . HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。 这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息 头中的元信息。
7. COPY：请求服务器将指定的页面copy到另外的页面。
8. TRACE：回显服务器收到的请求，主要用于测试或诊断。
9.  CONNECT : HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

#### GET和POST方法的区别

- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有 限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更 适合传输敏感信息。
- 从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结 果也是相同的)
- 从TCP的角度，GET产生一个TCP数据包；POST产生两个TCP数据包，对于GET 请求，浏览器会将head和data一并发送，成功响应200，对于POST先发送 header，成功响应100，浏览器再发送data，成功响应200；因此POST在时间 消耗上多；
- GET在URL中的长度被限制；

#### POST和PUT区别

POST请求会向指定资源提交数据，请求服务器进行处理，如︰表单数据提交、 文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个 请求可能会创建新的资源或/和修改现有资源。

PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该 方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

#### GET和HEAD区别

HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响 应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全 部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看 服务器的性能。

### HTTP响应报文

![image-20231229162646329](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/202312291626358.png)

#### 头字段

**通用字段**

|  首部字段名   |                     说明                      |
| :-----------: | :-------------------------------------------: |
| Cache-Control |                控制缓存的行为                 |
|  Connection   | 长短连接控制，如Connection:Keep-Alive / close |
|     Date      |              创建报文的日期时间               |
| Content-Type  |           表示报文主体的对象类型。            |

**请求字段**

|  首部字段名   |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|    Accept     | 请求报文可通过一个“Accept”报文头属性告诉服务端 客户端 接受什么类型的响应。 |
| AcceptCharset |                         优先的字符集                         |
|  User-Agent   |            客户端的信息，如：产生请求的浏览器类型            |
|     Host      |                       请求的服务器地址                       |
|    Cookie     |          客户端的Cookie通过这个报文头属性传给服务端          |
| Authorization |                         Web 认证信息                         |

**响应字段**

|    首部字段名     |                             说明                             |
| :---------------: | :----------------------------------------------------------: |
|   AcceptRanges    |                     是否接受字节范围请求                     |
|    Set-Cookie     | 服务端设置客户端的Cookie，如Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 |
|     Location      |                   令客户端重定向至指定 URI                   |
| ProxyAuthenticate |                 代理服务器对客户端的认证信息                 |
|      Server       |                    HTTP 服务器的安装信息                     |
|  WWWAuthenticate  |                   服务器对客户端的认证信息                   |

### HTTP是不保存状态的协议，如何保存用户状态

HTTP 是无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这 个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用 户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过 了时间限制，就会销毁这个Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数 据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

#### Cookie 被禁用怎么办?

**最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。或改用POST方法**

### Cookie的作用是什么? 和Session有什么区别？

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信 息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的 网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只 需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token重写)；③登录一次网站后访问网站其他页面不需要重新登录。

**Session 的主要作用就是通过服务端记录用户的状态**。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟 踪这个用户了。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更 高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

#### Session和Cookie的区别

Session是服务器用来跟踪用户状态的一种手段，每个Session都有一个唯一标识：Session ID。当服务器创建一个Session时，就将对应的用户信息保存在Session中。给客户端发送的响应报文就包含了Set-Cookie字段，然后将Session ID放在set cookie字段中发送给客户端。客户端收到后就把Cookie保存在浏览器中，并且之后发送的请求报文都包含Session ID。服务器就可以根据Session ID判断是哪个用户。HTTP就是Session和Cookie这两种方式一起合作来实现跟踪用户状态。**Session用于服务端，Cookie用于客户端。**

### 游览器缓存机制

浏览器第1次发出请求访问服务器上的1.jpg资源时，服务器会将1.jpg资源响应 给浏览器并带上名为Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT的响应头，其 中Tue, 11 Jul 2000 18:23:51 GMT为该资源的最后修改时间,响应的状态码是200， 由于浏览器是第一次访问1.jpg资源，所以在浏览器缓存文件中没有该资源,Tue, 11  Jul 2000 18:23:51 GMT作为时间戳和1.jpg资源一起存储在缓存文件中。

当浏览器第2次发出请求访问服务器上的1.jpg资源时,由于浏览器缓存中有1.jpg资 源,所以浏览器发出的请求会包含一个名为If-Modified-Since:Tue, 11 Jul 2000 18:23:51 GMT的请求头，其中Tue, 11 Jul 2000 18:23:51 GMT为1.jpg资源上一次 修改的时间,服务器接到请求后,会将发过来的这个时间与服务器中的1.jpg资源的最后 修改时间做对比，如果相同，服务器不会再将1.jpg资源响应给浏览器，并携带一个 304的状态码，告诉浏览器使用缓存获取图片，浏览器收到响应后去缓存中取出图片 显示在页面上。当然，如果服务器上的1.jpg资源发生了更新,浏览器发过来的时间与 服务器中的1.jpg资源的最后修改时间不同，服务器就会把最新的1.jpg资源响应给浏 览器，并携带一个200的状态码。

![image-20231229170132549](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/202312291701577.png)

### HTTP 1.0，HTTP 1.1有什么区别，及其改进

- **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为 缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，IfUnmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制 缓存策略。
- **带宽优化及网络连接的使用（Range字段）**，HTTP1.0中，存在一些浪费带宽的 现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来 了，并且不支持断点续传功能，HTTP1.1则在请求头引入了Range字段，它允许 只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开 发者自由的选择以便于充分利用带宽和连接。
- **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表 示服务器上的某个资源被永久性的删除。
- **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此， 请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发 展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支 持Host字段，且请求消息中如果没有Host字段会报告一个错误（400 Bad Request）。
- **长连接**，在HTTP/1.0中，默认使用的是短连接。HTTP 1.1默认使用长连接 （PersistentConnection），这减少了建立和关闭连接的消耗和延迟，一定程 度上弥补了HTTP1.0每次请求都要创建连接的缺点。另外，HTTP/1.1的长连接 有流水线方式和非流水线方式。流水线方式是客户端在收到HTTP的响应报文之 前就能接着发送新的请求报文。与之相对应的非流水线方式是客户端在收到前 一个响应后才能发送下一个请求。

![image-20231229170348618](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/202312291703649.png)

### HTTP2.0和HTTP1.X相比的新特性

- **帧：**HTTP2.0通信的最小单位，所有帧都共享一个8字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识帧，帧承载着标定类型的数据，如HTTP首部、负荷等。
- **消息：**比帧大的通讯单位，是指逻辑上的HTTP消息，比如请求、响应等。由一个或多个帧组成。
- **流：**比消息大的通讯单位，是TCP连接中的一个虚拟通道，可以承载双向的消息。每一个流都有一个唯一的整数标识符。

![20250123155420](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/20250123155420.png)

**二进制分帧（Binary Format）**，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，即帧格式，实现方便切健壮。

关键之一就是在应用层（HTTP/2）和传输层（TCP or UDP）之间增加一个二进制分帧层。二进制分帧层上，HTTP2.0将请求和响应数据分割为更小的帧，并且它们采用二进制编码。

![20250123155858](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/20250123155858.png)

**多路复用（Multiplexing）**，即连接共享，每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每一个连接的request可以随机混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某个请求超时等，后续请求只能被阻塞，即队头阻塞；（HTTP1.x中，如果想并发多个请求，必须使用多个TCP连接，且浏览器为了控制资源，会限制单个域名的TCP连接数量）
- HTTP/2多个请求可以同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其他连接的正常执行。HTTP/2中每个请求都被拆分成多个Frame，通过一条TCP连接同时被传输，这样即使一个请求被阻塞，也不会影响其他的请求。（同域名下所有通信都在一个TCP连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，容纳后根据帧首部的流标识重新组装。）如下图所示：
![20250123161244](https://tiny-blog.oss-cn-guangzhou.aliyuncs.com/blog/20250123161244.png)
